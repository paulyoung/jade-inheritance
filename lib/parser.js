// Generated by CoffeeScript 1.11.1
(function() {
  var Parser, fs, glob, nodePath, pkginfo, pugLex, pugParser, pugWalk, resolvePath;

  nodePath = require('path');

  fs = require('fs');

  glob = require('glob');

  pkginfo = JSON.parse(fs.readFileSync('./package.json', 'utf8'));

  pugLex = require('pug-lexer');

  pugParser = require('pug-parser');

  pugWalk = require('pug-walk');

  resolvePath = function(path, file, basedir, extension, purpose) {
    if (path[0] !== '/' && !file || path[0] !== '\\' && !file) {
      throw new Error('the "filename" option is required to use "' + purpose + '" with "relative" paths');
    }
    if (path[0] === '/' && !basedir || path[0] !== '\\' && !basedir) {
      throw new Error('the "basedir" option is required to use "' + purpose + '" with "absolute" paths');
    }
    path = nodePath.join((path[0] === '/' || path[0] === '\\' ? basedir : nodePath.dirname(file)), path);
    if (nodePath.basename(path).indexOf(extension) === -1) {
      path += extension;
    }
    return path;
  };

  Parser = (function() {
    function Parser(filename, directory, options) {
      var files;
      this.filename = filename;
      this.directory = directory;
      this.options = options;
      this.extension = '';
      if (this.options.extension) {
        this.extension = this.options.extension.indexOf('.') > -1 ? this.options.extension : '.' + this.options.extension;
      } else {
        this.extension = '.pug';
      }
      this.skipInheritances = this.options.skip ? this.options.skip : pkginfo.skipInheritances;
      this.cache = {};
      this.files = {};
      filename = nodePath.relative(this.options.basedir, filename);
      this.addFile(filename);
      files = glob.sync(this.directory + "/**/*" + this.extension);
      this.tree = this.getInheritance(filename, files);
      files = this.files;
      this.files = [];
      for (filename in files) {
        this.files.push(filename);
      }
      return this;
    }

    Parser.prototype.getInheritance = function(filename, files) {
      var branch, file, i, j, len, len1, ref, skip;
      this.addFile(filename);
      branch = {};
      if (branch[filename] == null) {
        branch[filename] = {};
      }
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        if (typeof this.skipInheritances === 'object') {
          ref = this.skipInheritances;
          for (j = 0, len1 = ref.length; j < len1; j++) {
            skip = ref[j];
            if (file.indexOf(skip) === -1) {
              this.createInheritanceObject(file, files, filename, branch);
            }
          }
        } else if (typeof this.skipInheritances === 'string') {
          if (file.indexOf(this.skipInheritances) === -1) {
            this.createInheritanceObject(file, files, filename, branch);
          }
        } else {
          console.warn('Skip inheritances is not set. This may throw an error, if basedir is set to "." and pug-inheritance is resolving files also in package folders.');
          this.createInheritanceObject(file, files, filename, branch);
        }
      }
      return branch;
    };

    Parser.prototype.createInheritanceObject = function(file, files, filename, branch) {
      var base, e, relativeFile, string;
      file = nodePath.normalize(file);
      relativeFile = nodePath.relative(this.options.basedir, file);
      file = nodePath.join(this.options.basedir, relativeFile);
      if ((base = this.cache)[file] == null) {
        base[file] = {};
      }
      if (this.cache[file].string != null) {
        string = this.cache[file].string;
      } else {
        string = this.cache[file].string = fs.readFileSync(file, 'utf8');
      }
      try {
        return pugWalk(pugParser(pugLex(string, {
          filename: file
        })), (function(_this) {
          return function(node) {
            var base1, inheritance, newFile, path, relationship, type;
            type = node.type;
            switch (type) {
              case 'Extends':
              case (_this.options.deprecated ? 'Include' : 'RawInclude'):
                path = resolvePath(node.file.path, file, _this.options.basedir, _this.extension, type);
                if (path === nodePath.join(_this.options.basedir, filename)) {
                  if (type === 'Extends') {
                    relationship = 'extendedBy';
                  } else if (type === 'RawInclude' || type === 'Include') {
                    relationship = 'includedBy';
                  }
                  newFile = {};
                  if (_this.cache[file].inheritance != null) {
                    inheritance = _this.cache[file].inheritance;
                  } else {
                    inheritance = _this.cache[file].inheritance = _this.getInheritance(relativeFile, files);
                  }
                  newFile = inheritance;
                  if ((base1 = branch[filename])[relationship] == null) {
                    base1[relationship] = [];
                  }
                  branch[filename][relationship].push(newFile);
                }
            }
            return branch;
          };
        })(this));
      } catch (error) {
        e = error;
        throw e;
      }
    };

    Parser.prototype.addFile = function(filename) {
      if (this.files[filename] == null) {
        return this.files[filename] = null;
      }
    };

    return Parser;

  })();

  module.exports = Parser;

}).call(this);
