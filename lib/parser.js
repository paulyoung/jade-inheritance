// Generated by CoffeeScript 1.6.3
(function() {
  var JadeParser, Parser, fs, glob, nodePath;

  nodePath = require('path');

  fs = require('fs');

  glob = require('glob');

  JadeParser = require('jade/lib/parser');

  Parser = (function() {
    function Parser(filename, directory, options) {
      var files;
      this.filename = filename;
      this.directory = directory;
      this.options = options;
      this.cache = {};
      this.files = {};
      filename = nodePath.relative(this.options.basedir, filename);
      this.addFile(filename);
      files = glob.sync("" + this.directory + "/**/*.jade");
      this.tree = this.getInheritance(filename, files);
      files = this.files;
      this.files = [];
      for (filename in files) {
        this.files.push(filename);
      }
      return this;
    }

    Parser.prototype.getInheritance = function(filename, files) {
      var branch, file, _fn, _i, _len,
        _this = this;
      this.addFile(filename);
      branch = {};
      if (branch[filename] == null) {
        branch[filename] = {};
      }
      _fn = function(file) {
        var e, inheritance, newFile, parser, path, relationship, relativeFile, string, type, _base, _base1, _results;
        file = nodePath.normalize(file);
        relativeFile = nodePath.relative(_this.options.basedir, file);
        file = nodePath.join(_this.options.basedir, relativeFile);
        if ((_base = _this.cache)[file] == null) {
          _base[file] = {};
        }
        if (_this.cache[file].string != null) {
          string = _this.cache[file].string;
        } else {
          string = _this.cache[file].string = fs.readFileSync(file, 'utf8');
        }
        parser = new JadeParser(string, file, _this.options);
        _results = [];
        while (true) {
          try {
            if ((type = parser.peek().type) === 'eos') {
              break;
            }
          } catch (_error) {
            e = _error;
            e.message += file;
            throw e;
          }
          switch (type) {
            case 'extends':
            case 'include':
              path = parser.expect(type).val.trim();
              path = parser.resolvePath(path, type);
              if (path === nodePath.join(_this.options.basedir, filename)) {
                if (type === 'extends') {
                  relationship = 'extendedBy';
                } else if (type === 'include') {
                  relationship = 'includedBy';
                }
                newFile = {};
                if (_this.cache[file].inheritance != null) {
                  inheritance = _this.cache[file].inheritance;
                } else {
                  inheritance = _this.cache[file].inheritance = _this.getInheritance(relativeFile, files);
                }
                newFile = inheritance;
                if ((_base1 = branch[filename])[relationship] == null) {
                  _base1[relationship] = [];
                }
                _results.push(branch[filename][relationship].push(newFile));
              } else {
                _results.push(void 0);
              }
              break;
            default:
              _results.push(parser.advance());
          }
        }
        return _results;
      };
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        _fn(file);
      }
      return branch;
    };

    Parser.prototype.addFile = function(filename) {
      if (this.files[filename] == null) {
        return this.files[filename] = null;
      }
    };

    return Parser;

  })();

  module.exports = Parser;

}).call(this);
